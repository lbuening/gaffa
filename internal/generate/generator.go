// Package generate contains code which is almost completely stolen from Service Weaver.
// The only difference is that weaver.Implements[T] is replaced with gaffa.Implements[T].
package generate

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/lbuening/gaffa/internal/files"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io"
	"path"
	"path/filepath"
	"sort"
)

const generatedCodeFile = "gaffa_gen.go"
const Usage = `
Generate code for a Gaffa application.

Usage:
  gaffa generate [packages]

Description:
  "gaffa generate" generates code for the Gaffa applications in the
  provided packages. For example, "gaffa generate . ./foo" will generate code
  for the Gaffa applications in the current directory and in the ./foo
  directory. For every package, the generated code is placed in a gaffa_gen.go
  file in the package's directory. For example, "gaffa generate . ./foo" will
  create ./gaffa_gen.go and ./foo/gaffa_gen.go.

  You specify packages for "gaffa generate" in the same way you specify
  packages for go build, go test, go vet, etc. See "go help packages" for more
  information.

  Rather than invoking "gaffa generate" directly, you can place a line of the
  following form in one of the .go files in the package:

      //go:generate gaffa generate

  and then use the normal "go generate" command.

Examples:
  # Generate code for the package in the current directory.
  gaffa generate

  # Same as "gaffa generate".
  gaffa generate .

  # Generate code for the package in the ./foo directory.
  gaffa generate ./foo

  # Generate code for all packages in all subdirectories of current directory.
  gaffa generate ./...
`

func Generate(dir string, pkgs []string) error {
	fset := token.NewFileSet()
	cfg := &packages.Config{
		Mode:       packages.NeedName | packages.NeedSyntax | packages.NeedImports | packages.NeedTypes | packages.NeedTypesInfo,
		Dir:        dir,
		Fset:       fset,
		ParseFile:  parseNonGaffaGenFile,
		BuildFlags: []string{"--tags=ignoreGaffaGen"},
	}
	pkgList, err := packages.Load(cfg, pkgs...)
	if err != nil {
		return fmt.Errorf("packages.Load: %w", err)
	}

	var errs []error
	for _, pkg := range pkgList {
		g, err := newGenerator(pkg, fset)
		if err != nil {
			errs = append(errs, err)
			continue
		}
		if err := g.generate(); err != nil {
			errs = append(errs, err)
		}
	}
	return errors.Join(errs...)
}

// parseNonWeaverGenFile parses a Go file, except for gaffa_gen.go files whose
// contents are ignored since those contents may reference types that no longer
// exist.
func parseNonGaffaGenFile(fset *token.FileSet, filename string, src []byte) (*ast.File, error) {
	if filepath.Base(filename) == generatedCodeFile {
		return parser.ParseFile(fset, filename, src, parser.PackageClauseOnly)
	}
	return parser.ParseFile(fset, filename, src, parser.ParseComments|parser.DeclarationErrors)
}

type generator struct {
	pkg        *packages.Package
	fileset    *token.FileSet
	components []*component
}

func (g *generator) generate() error {
	if len(g.components) == 0 {
		// Nothing to generate
		return nil
	}

	// Process components in deterministic order.
	sort.Slice(g.components, func(i, j int) bool {
		return g.components[i].intfName() < g.components[j].intfName()
	})

	buffer := &bytes.Buffer{}

	// Write the header.
	buffer.WriteString("// Code generated by \"gaffa generate\". DO NOT EDIT.\n")
	buffer.WriteString("//go:build !ignoreGaffaGen\n")
	buffer.WriteString("\n")
	buffer.WriteString("package " + g.pkg.Name + "\n")
	buffer.WriteString("\n")
	buffer.WriteString("import (\n")
	g.importPackage(buffer, path.Join(gaffaPackagePath, "registry"), "reflect")

	// Check if the package has any Main components. If so, import the gaffa package
	// so that we can call gaffa.Main.
	for _, c := range g.components {
		if c.isMain {
			g.importPackage(buffer, gaffaPackagePath)
			break
		}
	}

	buffer.WriteString(")\n")
	buffer.WriteString("\n")

	// Write the init function.
	buffer.WriteString("func init() {\n")
	for _, c := range g.components {
		if err := g.generateComponent(buffer, c); err != nil {
			return err
		}
	}
	buffer.WriteString("}\n")

	filename := filepath.Join(g.pkgDir(), generatedCodeFile)
	dst := files.NewWriter(filename)
	defer dst.Cleanup()

	b := buffer.Bytes()
	formatted, err := format.Source(b)
	if err != nil {
		return fmt.Errorf("format.Source: %w", err)
	}
	b = formatted

	// Write to dst.
	_, err = io.Copy(dst, bytes.NewReader(b))
	if err != nil {
		return fmt.Errorf("io.Copy: %w", err)
	}

	return dst.Close()
}

// pkgDir returns the directory of the package.
func (g *generator) pkgDir() string {
	if len(g.pkg.Syntax) == 0 {
		panic(fmt.Errorf("package %v has no source files", g.pkg))
	}
	f := g.pkg.Syntax[0]
	fname := g.fileset.Position(f.Package).Filename
	return filepath.Dir(fname)
}

func (g *generator) generateComponent(buffer *bytes.Buffer, c *component) error {
	buffer.WriteString("\tregistry.Register(registry.Registration{\n")
	if c.isMain {
		buffer.WriteString("\t\tIface:     reflect.TypeOf((*gaffa.Main)(nil)).Elem(),\n")
	} else {
		buffer.WriteString("\t\tIface:     reflect.TypeOf((*" + c.intfName() + ")(nil)).Elem(),\n")
	}
	buffer.WriteString("\t\tImpl:      reflect.TypeOf(" + c.impl.Obj().Name() + "{}),\n")
	buffer.WriteString("\t})\n")
	return nil
}

func (g *generator) importPackage(buffer *bytes.Buffer, packages ...string) {
	for _, pkg := range packages {
		buffer.WriteString("\t\"" + pkg + "\"\n")
	}
}

// errorf is like fmt.Errorf but prefixes the error with the provided position.
func errorf(fset *token.FileSet, pos token.Pos, format string, args ...interface{}) error {
	// Rewrite the position's filename relative to the current directory. This
	// replaces long filenames like "/home/foo/repos/gaffa/gaffa.go"
	// with much shorter filenames like "./gaffa.go".
	position := fset.Position(pos)
	if cwd, err := filepath.Abs("."); err == nil {
		if filename, err := filepath.Rel(cwd, position.Filename); err == nil {
			position.Filename = filename
		}
	}

	return fmt.Errorf("%s: %w", position.String(), fmt.Errorf(format, args...))
}

func newGenerator(pkg *packages.Package, fset *token.FileSet) (*generator, error) {
	var errs []error
	for _, err := range pkg.Errors {
		errs = append(errs, err)
	}
	if err := errors.Join(errs...); err != nil {
		return nil, err
	}

	var components []*component
	for _, file := range pkg.Syntax {
		filename := fset.Position(file.Package).Filename
		if filepath.Base(filename) == generatedCodeFile {
			// Ignore gaffa_gen.go files.
			continue
		}

		fileComponents, err := findComponents(pkg, file)
		if err != nil {
			errs = append(errs, err)
			continue
		}

		// The original code of Service Weaver would have thrown away duplicated components.
		// We like em so we keep em. This is a breaking change.
		// We can handle them because we will use a tag based system to identify which component should be used.
		// Or if multiple components have been registered we will throw an error at runtime.

		components = append(components, fileComponents...)
	}

	if err := errors.Join(errs...); err != nil {
		return nil, err
	}

	return &generator{
		pkg:        pkg,
		fileset:    fset,
		components: components,
	}, nil
}

// findComponents returns the components in the provided file. For example,
// findComponents will find and return the following component.
//
//	type something struct {
//	    gaffa.Implements[SomeComponentType]
//	    ...
//	}
func findComponents(pkg *packages.Package, f *ast.File) ([]*component, error) {
	var components []*component
	var errs []error
	for _, d := range f.Decls {
		gendecl, ok := d.(*ast.GenDecl)
		if !ok || gendecl.Tok != token.TYPE {
			continue
		}
		for _, spec := range gendecl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			component, err := extractComponent(pkg, ts)
			if err != nil {
				errs = append(errs, err)
				continue
			}
			if component != nil {
				components = append(components, component)
			}
		}
	}
	return components, errors.Join(errs...)
}

type component struct {
	// intf is the interface type that the component implements.
	intf *types.Named
	// impl is the implementation type of the component.
	impl *types.Named
	// isMain is true if the component implements the gaffa.Main interface.
	isMain bool
	// hasInit is true if the component has an Init method.
	hasInit bool
	refs    []*types.Named
}

func (c *component) intfName() string {
	return c.intf.Obj().Name()
}

// fullIntfName returns the full package-prefixed component interface name.
func (c *component) fullIntfName() string {
	return fullName(c.intf)
}

// extractComponent attempts to extract a component from the provided TypeSpec.
// It returns a nil component if the TypeSpec doesn't define a component.
func extractComponent(pkg *packages.Package, spec *ast.TypeSpec) (*component, error) {
	// Check that the type spec is of the form `type t struct {...}`.
	s, ok := spec.Type.(*ast.StructType)
	if !ok {
		// This type declaration does not involve a struct. For example, it
		// might look like `type t int`. These non-struct type declarations
		// cannot be components.
		return nil, nil
	}
	def, ok := pkg.TypesInfo.Defs[spec.Name]
	if !ok {
		panic(errorf(pkg.Fset, spec.Pos(), "name %v not found", spec.Name))
	}
	impl, ok := def.Type().(*types.Named)
	if !ok {
		// For type aliases like `type t = struct{}`, t has type *types.Struct
		// and not type *types.Named. We ignore these.
		return nil, nil
	}

	// Find any gaffa.Implements[T] embedded fields.
	var intf *types.Named   // The component interface type
	var isMain bool         // Is intf gaffa.Main?
	var refs []*types.Named // T for which gaffa.Ref[T] exists in struct
	for _, f := range s.Fields.List {
		typeAndValue, ok := pkg.TypesInfo.Types[f.Type]
		if !ok {
			panic(errorf(pkg.Fset, f.Pos(), "type %v not found", f.Type))
		}
		t := typeAndValue.Type

		if isGaffaRef(t) {
			// The field f has type gaffa.Ref[T].
			arg := t.(*types.Named).TypeArgs().At(0)
			if isGaffaMain(arg) {
				return nil, errorf(pkg.Fset, f.Pos(),
					"components cannot contain a reference to gaffa.Main")
			}
			named, ok := arg.(*types.Named)
			if !ok {
				return nil, errorf(pkg.Fset, f.Pos(),
					"gaffa.Ref argument %s is not a named type.",
					formatType(pkg, arg))
			}
			refs = append(refs, named)
		}

		if len(f.Names) != 0 {
			// Ignore unembedded fields.
			//
			// TODO(mwhittaker): Warn the user about unembedded
			// gaffa.Implements, gaffa.WithConfig, or gaffa.WithRouter?
			continue
		}

		switch {
		// The field f is an embedded gaffa.Implements[T].
		case isGaffaImplements(t):
			// Check that T is a named interface type inside the package.
			arg := t.(*types.Named).TypeArgs().At(0)
			named, ok := arg.(*types.Named)
			if !ok {
				return nil, errorf(pkg.Fset, f.Pos(),
					"gaffa.Implements argument %s is not a named type.",
					formatType(pkg, arg))
			}
			isMain = isGaffaMain(arg)
			if !isMain && named.Obj().Pkg() != pkg.Types {
				return nil, errorf(pkg.Fset, f.Pos(),
					"gaffa.Implements argument %s is a type outside the current package. A component interface and implementation must be in the same package. If you can't move them into the same package, you can add `type %s %v` to the implementation's package and embed `gaffa.Implements[%s]` instead of `gaffa.Implements[%s]`.",
					formatType(pkg, named), named.Obj().Name(), formatType(pkg, named), named.Obj().Name(), formatType(pkg, named))
			}
			if _, ok := named.Underlying().(*types.Interface); !ok {
				return nil, errorf(pkg.Fset, f.Pos(),
					"gaffa.Implements argument %s is not an interface.",
					formatType(pkg, named))
			}
			intf = named
		}
	}

	if intf == nil {
		return nil, nil
	}

	// Check that that the component implementation implements the component
	// interface.
	if !types.Implements(types.NewPointer(impl), intf.Underlying().(*types.Interface)) {
		return nil, errorf(pkg.Fset, spec.Pos(),
			"type %s embeds gaffa.Implements[%s] but does not implement interface %s.",
			formatType(pkg, impl), formatType(pkg, intf), formatType(pkg, intf))
	}

	// Disallow generic component implementations.
	if spec.TypeParams != nil && spec.TypeParams.NumFields() != 0 {
		return nil, errorf(pkg.Fset, spec.Pos(),
			"component implementation %s is generic. Component implements cannot be generic.",
			formatType(pkg, impl))
	}

	// Warn the user if the component has a mistyped Init method. Init methods
	// are supposed to have type "func(context.Context) error", but it's easy
	// to forget to add a context.Context argument or error return. Without
	// this warning, the component's Init method will be silently ignored. This
	// can be very frustrating to debug.
	hasInit, err := checkMistypedInit(pkg, impl)
	if err != nil {
		return nil, errorf(pkg.Fset, spec.Pos(), "%w", err)
	}

	return &component{
		intf:    intf,
		impl:    impl,
		isMain:  isMain,
		hasInit: hasInit,
		refs:    refs,
	}, nil
}

// checkMistypedInit returns an error if the provided component implementation
// has an Init method that does not have type "func(context.Context) error".
func checkMistypedInit(pkg *packages.Package, impl *types.Named) (bool, error) {
	for i := 0; i < impl.NumMethods(); i++ {
		m := impl.Method(i)
		if m.Name() != "Init" {
			continue
		}

		// TODO(mwhittaker): Highlight the warning yellow instead of red.
		sig := m.Type().(*types.Signature)
		err := errorf(pkg.Fset, m.Pos(),
			`WARNING: Component %v's Init method has type "%v", not type "func(context.Context) error". It will be ignored. See https://serviceweaver.dev/docs.html#components-implementation for more information.`,
			impl.Obj().Name(), sig)

		// Check Init's parameters.
		if sig.Params().Len() != 1 || !isContext(sig.Params().At(0).Type()) {
			return false, err
		}

		// Check Init's returns.
		if sig.Results().Len() != 1 || sig.Results().At(0).Type().String() != "error" {
			return false, err
		}
		return true, nil
	}
	return false, nil
}

func fullName(t *types.Named) string {
	return path.Join(t.Obj().Pkg().Path(), t.Obj().Name())
}

// formatType pretty prints the provided type, encountered in the provided
// currentPackage.
func formatType(currentPackage *packages.Package, t types.Type) string {
	qualifier := func(pkg *types.Package) string {
		if pkg == currentPackage.Types {
			return ""
		}
		return pkg.Name()
	}
	return types.TypeString(t, qualifier)
}
